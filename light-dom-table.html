<script>
  /**
   * @polymerBehavior vaadin.elements.grid.LightDomTable
   */
  vaadin = window.vaadin || {};
  vaadin.elements = window.vaadin.elements || {};
  vaadin.elements.grid = window.vaadin.elements.grid || {};
  vaadin.elements.grid.LightDomTable = {

    properties: {

      _mutationObserver: {
        value: function() {
          return new MutationObserver(this._lightDomTableChanged.bind(this));
        }
      },

      _lightDomTable: {
        observer: '_lightDomTableChanged'
      }
    },

    ready: function() {
      Polymer.dom(this).observeNodes(function(info) {
        info.addedNodes.forEach(function(node) {
          if (node.tagName === 'TABLE') {
            this._lightDomTable = node;
          }
        }.bind(this));
      });
    },

    _lightDomTableChanged: function() {
      this._mutationObserver.disconnect();

      var table = this.queryEffectiveChildren('table');
      this.header.defaultRow = 0;

      var tbody = table.querySelector('tbody');
      this._tableDs = undefined;
      if (tbody) {
        this._tableDs = this._createTableDs(tbody);
        this.items = this._tableDs;
      }
      this.columns = this._createTableColumns(table.querySelector('colgroup'));
      this.sortOrder = this._getSortOrder();


      this._tableInitStaticSection(this.header, table.querySelector('thead'));
      this._tableInitStaticSection(this.footer, table.querySelector('tfoot'));

      var defaultRow = this._getHeaderDefaultRow();
      if (defaultRow !== 0) {
        this.header.defaultRow = defaultRow;
      }

      var config = {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      };
      this._mutationObserver.observe(this._lightDomTable, config);
    },

    _getHeaderDefaultRow: function(thead) {
      var rows = Polymer.dom(thead).querySelectorAll('tr');
      return rows.reduce(function(prev, row, index) {
        return row.childElementCount > rows[prev].childElementCount || row.hasAttribute('sortable') ? index : prev;
      }, 0);
    },

    _getSortOrder: function() {
      return this.columns.reduce(function(prev, col, index) {
        if (col.sortDirection) {
          prev.push({
            column: index,
            direction: col.sortDirection
          });
          delete col.sortDirection;
        }
        return prev;
      }, []) || undefined;
    },

    _createTableColumns: function(colgroup) {
      return Polymer.dom(colgroup).querySelectorAll('col').map(function(col) {
        var column = {
          name: col.getAttribute('name') || undefined,
          hidingToggleText: col.getAttribute('hiding-toggle-text') || undefined,
          width: this._parseIntAttribute(col, 'width'),
          maxWidth: this._parseIntAttribute(col, 'max-width'),
          minWidth: this._parseIntAttribute(col, 'min-width'),
          flex: this._parseIntAttribute(col, 'flex', 1, -1),
          sortable: col.hasAttribute('sortable'),
          sortDirection: col.getAttribute('sort-direction') || undefined,
          hidable: col.hasAttribute('hidable'),
          hidden: col.hasAttribute('hidden')
        };

        if (this._tableDs) {
          column.renderer = function(cell) {
            if (this.items === this._tableDs) {
              cell.element.innerHTML = "";
              cell.element.appendChild(cell.data);
            } else {
              // The datasource might be changed so we need to provide default renderer also
              this._defaultRenderer(cell);
            }
          }.bind(this);
        }
        return column;
      }, this);
    },

    _defaultRenderer: function(cell) {
      var element = cell.element;
      var content = (cell.data === undefined || cell.data === null) ? "" : cell.data;
      var wrapper = element.firstElementChild;
      if (!wrapper || !wrapper.iswrapper) {
          // Need to create a new wrapper
          wrapper = document.createElement('span');
          wrapper.style.overflow = 'hidden';
          wrapper.style.textOverflow = 'ellipsis';
          wrapper.iswrapper = true;
          element.innerHTML = "";
          element.appendChild(wrapper);
      }
      wrapper.textContent = content;
    },

    _parseIntAttribute: function(element, attribute, valueOnEmpty, valueOnUndefined) {
      return element.hasAttribute(attribute) ? parseInt(element.getAttribute(attribute)) || valueOnEmpty : valueOnUndefined;
    },

    _createTableDs: function(tbody) {
      return Polymer.dom(tbody).querySelectorAll('tr').map(function(tr) {
        return Polymer.dom(tr).querySelectorAll('td').map(function(td) {
          return this._extractCellContent(td);
        }, this);
      }, this);
    },

    _tableInitStaticSection: function(section, contextElement) {
      while (section.rowCount > section === this.header ? 1 : 0) {
        section.removeRow();
      }
      if (contextElement) {
        section.hidden = contextElement.hasAttribute('hidden');
        this._tableInitStaticSectionRows(section, Polymer.dom(contextElement).querySelectorAll('tr'));
      }
    },

    _tableInitStaticSectionRows: function(section, rows) {
      rows.forEach(function(tr, row) {
        if (section.rowCount < row + 1) {
          section.addRow();
        }
        section.setRowClassName(row, tr.getAttribute('class'));

        var cells = Polymer.dom(tr).querySelectorAll('th, td');
        this._tableInitStaticSectionRowCells(section, cells, row);
      }, this);
    },

    _tableInitStaticSectionRowCells: function(section, cells, row) {
      var span = 0;
      cells.forEach(function(td, col) {
        var cell = section.getCell(row, col + span);
        cell.className = td.getAttribute('class');
        cell.content = this._extractCellContent(td);

        // FIXME: Need to enforce the cell content (to make it show visually).
        // Some internal async problem.
        this.async(function() {
          this.then(function() {
            cell.content = cell.content;
          });
        }, 1);

        var colspan = td.getAttribute('colspan');
        cell.colspan = colspan ? parseInt(colspan) : 1;
        span += cell.colspan - 1;
      }, this);
    },

    _extractCellContent: function(cell) {
      var wrapper = document.createElement('span');
      var nodes = cell.childNodes;
      if (!cell.firstElementChild) {
        wrapper.style.overflow = 'hidden';
        wrapper.style.textOverflow = 'ellipsis';
      } else if (nodes.length === 1) {
        return nodes[0];
      }

      for (var i = 0; i < nodes.length; i++) {
        Polymer.dom(wrapper).appendChild(nodes[i--]);
      }
      return wrapper;
    }

  };
</script>
