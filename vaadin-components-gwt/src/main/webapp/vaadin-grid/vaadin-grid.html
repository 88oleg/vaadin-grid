<link rel='import' href='vaadin-grid-import.html'>
<link rel='import' href='../../bower_components/polymer/polymer.html'>
<script src="../../bower_components/object.observe/dist/object-observe-lite.min.js"></script>
<link rel="stylesheet" href="vaadin-grid.css" shim-shadowdom>

<dom-module id="v-grid">
  <template>
  </template>
</dom-module>


<script>
  var prototype = {
    is: "v-grid",

    grid: undefined,

    published: {

      /**
       * Sets current selection mode.
       *
       * @attribute selectionMode
       * @type String
       */
      selectionMode: {
        reflect: true,
        type: String
      },

      /**
       * Sets whether this widget is disabled.
       *
       * @attribute disabled
       * @type boolean
       */
      disabled: {
        reflect: true,
        type: Boolean
      },

      /**
       * Sets the enabled state of the editor.
       *
       * @attribute editable
       * @type boolean
       */
      editable: {
        reflect: true,
        type: Boolean
      },

      /**
       * Sets the number of frozen columns in this grid. Setting the count to 0
       * means that no data columns will be frozen, but the built-in selection
       * checkbox column will still be frozen if it's in use. Setting the count to
       * -1 will also disable the selection column.
       *
       * @attribute frozenColumn
       * @type String
       */
      frozenColumn: {
        reflect: true,
        type: String
      },

      /**
       * Sets the theme
       *
       * @attribute theme
       * @type String
       */
      theme: {
        reflect: true,
        type: String
      }
    },

    bind: {
      selectionMode: 'grid.setSelectionMode',
      dataSource: 'grid.setDataSource',
      disabled: 'grid.setDisabled',
      editable: 'editableChanged',
      frozenColumn: 'grid.setFrozenColumn',
      rows: 'grid.setRowCount',
      /**
       * Sets the row count
       *
       * @attribute rowCount
       * @type number
       */
      rowCount: 'grid.setRowCount'
    },

    editableChanged: function(editable) {
      this.editor.enabled = editable;
    },

    attributeChanged: function(name, type, value) {
      switch (name) {
        case 'selected-rows':
          this.selectedRows = value.split(',').map(function(x) {
            return parseInt(x, 10);
          }).filter(function(x) {
            return !isNaN(x);
          });
          break;
        case 'selection-mode':
          this.selectionMode = value;
          break;
        case 'disabled':
          this.disabled = typeof value == "string";
          break;
        case 'editable':
          this.editable = typeof value == "string";
          break;
        case 'frozen-column':
          this.frozenColumn = value;
          break;
        case 'theme':
          this.theme = value;
          break;
      }
    },

    listeners: {
      /**
       * @event select
       */
      'select': 'onSelect'
    },

    editor: {},

    onSelect: function() {
      this.setAttribute('selected-rows', this.selectedRows.join());
    },

    selectionModeChanged: function(mode) {
      this.grid.setSelectionMode(mode);
    },

    created: function() {
      this.grid = new vaadin.GridComponent();
    },

    ready: function() {
      this.grid.init(this, this.lightDom.querySelector("table"), this.localDom);

      var _this = this;
      this.editor = {
        gridEditor: _this.grid.getEditor(),

        get enabled() {
          return this.gridEditor.isEnabled();
        },
        set enabled(enabled) {
          _this.editable = enabled;
          this.gridEditor.setEnabled(enabled);
        },
        get handler() {
          return this.gridEditor.getHandler();
        },
        set handler(handler) {
          this.gridEditor.setHandler(handler);
        },
        get saveButtonText() {
          return this.gridEditor.getSaveButtonText();
        },
        set saveButtonText(saveButtonText) {
          this.gridEditor.setSaveButtonText(saveButtonText);
        },
        get cancelButtonText() {
          return this.gridEditor.getSaveButtonText();
        },
        set cancelButtonText(cancelButtonText) {
          this.gridEditor.setCancelButtonText(cancelButtonText);
        },
        editRow: function(row) {
          this.gridEditor.editRow(row);
        },
        save: function() {
          this.gridEditor.save();
        },
        cancel: function() {
          this.gridEditor.cancel();
        }
      };

      Object.defineProperty(this, 'scrollTop', {
        get: function() {
          return this.grid.getScrollTop();
        },
        set: function(newValue) {
          this.grid.setScrollTop(newValue);
        },
        enumerable: true,
        configurable: false
      });
    },

    /**
     * Scrolls to a certain row, using user-specified scroll destination.
     *
     * @method scrollToRow
     * @param {number} index - zero-based index of the row to scroll to.
     * @param {string} scrollDestination - desired destination placement of scrolled-to-row.
     */
    scrollToRow: function(index, scrollDestination) {
      this.grid.scrollToRow(index, scrollDestination);
    },

    /**
     * Scrolls to the beginning of the very first row.
     *
     * @method scrollToStart
     */
    scrollToStart: function() {
      this.grid.scrollToStart();
    },

    /**
     * Scrolls to the end of the very last row.
     *
     * @method scrollToEnd
     */
    scrollToEnd: function() {
      this.grid.scrollToEnd();
    },

    /**
     * Selects certain row
     *
     * @method select
     * @param {Object} value
     */
    select: function(value) {
      var array = this.selectedRows;
      if (array.indexOf(value) == -1) {
        array.push(value);
        this.selectedRows = array;
      }
    },

    /**
     * Deselects certain row
     *
     * @method select
     * @param {Object} value
     */
    deselect: function(value) {
      var array = this.selectedRows;
      var index = array.indexOf(value);
      if (index > -1) {
        array.splice(index, 1);
        this.selectedRows = array;
      }
    },

    /**
     * Deselects certain row
     *
     * @method select
     * @param {Object} column
     * @param {string} beforeColumn
     */
    addColumn: function(column, beforeColumn) {
      this.grid.addColumn(column, beforeColumn);
    },

    /**
     * Removes column with certain id
     *
     * @method removeColumn
     * @param {string} id
     */
    removeColumn: function(id) {
      this.grid.removeColumn(id);
    },

    /**
     * The selected rows array
     *
     * @attribute selectedRows
     * @type array
     */
    set selectedRows(r) {
      return this.grid.setSelectedRows(r);
    },
    get selectedRows() {
      return this.grid.getSelectedRows();
    },

    /**
     * The columns array
     *
     * @attribute columns
     * @type array
     */
    set columns(r) {
      this.grid.setColumns(r);
    },
    get columns() {
      return this.grid.getColumns();
    },

    /**
     * The datasource
     *
     * @attribute datasource
     * @type object
     */
    get datasource() {
      return this.grid.getDataSource();
    },

    /**
     * Sets the sort order to use. Setting this causes the Grid to re-sort
     * itself. If set to null, the sort order is cleared.
     *
     * @attribute sortOrder
     * @type array
     */
    get sortOrder() {
      return this.grid.getSortOrder();
    },
    set sortOrder(sortOrder) {
      this.grid.setSortOrder(sortOrder);
    },
    /**
     * Sets the style generator that is used for generating styles for rows.
     *
     * @attribute rowClassName
     * @type object
     */
    get rowClassName() {
      return this.grid.getRowClassName();
    },
    set rowClassName(rowClassName) {
      this.grid.setRowClassName(rowClassName);
    },
    /**
     * Sets the style generator that is used for generating styles for cells.
     *
     * @attribute cellClassName
     * @type object
     */
    get cellClassName() {
      return this.grid.getCellClassName();
    },
    set cellClassName(cellClassName) {
      this.grid.setCellClassName(cellClassName);
    },
  };

  function loadComponent() {
    VGrid = Polymer(prototype);
    // Give some time to gwt async processes to run (we need this in FF)
    setTimeout(function() {
      vaadin._v_grid_ready = true;
      document.dispatchEvent(new Event('v-grid-ready'));
    }, 5);
  }

  if (window.vaadin && window.vaadin.GridComponent) {
    loadComponent();
  } else {
    document.addEventListener("v-grid-loaded", function() {
      loadComponent();
    });
  }
</script>
